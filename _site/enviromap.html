<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>teapot-demo</title>
<meta property="og:title" content="teapot-demo" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/enviromap.html" />
<meta property="og:url" content="http://localhost:4000/enviromap.html" />
<meta property="og:site_name" content="teapot-demo" />
<script type="application/ld+json">
{"name":null,"description":null,"author":null,"@type":"WebPage","url":"http://localhost:4000/enviromap.html","publisher":null,"image":null,"headline":"teapot-demo","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=78e02b4b785906d50d47c64eb8ad7d8e470bdbe5">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="http://github.com/pages/k1mby/teapot-demo"> <h1>teapot-demo</h1> </a>
        <p></p>

        
          <!--<p class="view"><a href="http://github.com/k1mby/teapot-demo">View the Project on GitHub <small></small></a></p>-->
        

        

        
          <br>
          <ul class="downloads">
            <li><a href="https://github.com/k1mby/teapot-demo/archive/master.zip">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/k1mby/teapot-demo/archive/master.tar.gz">Download <strong>TAR Ball</strong></a></li>
            <li><a href="http://github.com/k1mby/teapot-demo">View On <strong>GitHub</strong></a></li>
          </ul>
          <br>
        
          <h3>Documentation</h3>
          <a href="intro.html">Getting Started</a><br>
          <a href="shading.html">Shading Models</a><br>
          <a href="enviromap.html">Environment Mapping</a>
          <br><br><br>
          <p class="demo-link"><a href="https://k1mby.github.io/teapot-demo/src/demo.html">DEMO</a></p>
      </header>
      <section>

      <p><a name="top"></a></p>
<h2 id="environment-mapping">Environment Mapping</h2>

<p>Environment mapping or <a href="https://en.wikipedia.org/wiki/Reflection_mapping">reflection mapping</a> uses texture mapping to create the appearance of reflections on surfaces. In this demo we first set up a skybox for our background. We can then implement reflection and refraction by sampling the cubemap texture, this is known as cubemapping.</p>

<p><strong>Jump to Section</strong>:</p>

<p><a href="#skybox">Skybox</a><br />
<a href="#reflection">Reflection</a><br />
<a href="#refraction">Refraction</a></p>

<p><a href="./">Back to main</a>
<br />
<br /></p>

<hr />

<p><a name="skybox"></a></p>
<h3 id="skybox">Skybox</h3>

<p>A skybox is essentially a cube that surrounds the scene. The six inner walls of the cube then act as a distant background. Setting up the skybox requires a bit more than just creating uniforms so included below is some of the Javascript in addition to the shader code.</p>

<p>To set up the skybox we need the images that will be used for the cubemap. All of the skyboxes in the demo are from <a href="http://www.custommapmakers.org/skyboxes.php">Custom Map Makers</a>. We need six images to represent the six sides of the skybox.</p>

<p>The last two characters in the image name identify which side of the cube that particular image corresponds to, for example the image below is the front face of the whirlpool cubemap.</p>

<p><code class="highlighter-rouge">whirlpool_ft.png</code></p>

<p>We use ft, bk, up, down, rt, lf to represent front, back, up, down, right, and left respectively.</p>

<p>We need to be sure to load the images in the right order so the cube is assembled properly. We will do this using Three.js <code class="highlighter-rouge">CubeTextureLoader()</code>. The order the images should be loaded in is specified as follows:</p>

<p><code class="highlighter-rouge">px.png</code><br />
		<code class="highlighter-rouge">nx.png</code><br />
		<code class="highlighter-rouge">py.png</code><br />
		<code class="highlighter-rouge">ny.png</code><br />
		<code class="highlighter-rouge">pz.png</code><br />
		<code class="highlighter-rouge">nz.png</code></p>

<p>Where px corresponds to positive x, nx corresponds to negative x and so on. To clarify:</p>

<p><code class="highlighter-rouge">positive x = front</code><br />
<code class="highlighter-rouge">negative x = back</code><br />
<code class="highlighter-rouge">positive y = up</code><br />
<code class="highlighter-rouge">negative y = down</code><br />
<code class="highlighter-rouge">positive z = right</code><br />
<code class="highlighter-rouge">negative z = left</code></p>

<p>We load the cubemap as below and then pass this to the shader as a uniform.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">cubemap</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">THREE</span><span class="p">.</span><span class="nx">CubeTextureLoader</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">setPath</span><span class="p">(</span> <span class="s1">'img/whirlpool/'</span> <span class="p">)</span>
  <span class="p">.</span><span class="nx">load</span><span class="p">([</span>
    <span class="s1">'whirlpool_ft.png'</span><span class="p">,</span> <span class="s1">'whirlpool_bk.png'</span><span class="p">,</span>
    <span class="s1">'whirlpool_up.png'</span><span class="p">,</span> <span class="s1">'whirlpool_dn.png'</span><span class="p">,</span>
    <span class="s1">'whirlpool_rt.png'</span><span class="p">,</span> <span class="s1">'whirlpool_lf.png'</span>
  <span class="p">]);</span>
</code></pre></div></div>

<p>The other thing we need to do in our Javascript is create the actual cube geometry. We can do this using the Three.js <code class="highlighter-rouge">BoxGeometry()</code>. One thing to note is that the size of the box won’t change how it looks, it just needs to be large enough to account for where things in the scene are positioned.</p>

<h3 id="vertex-shader">Vertex Shader</h3>

<p>Our skybox shader has one uniform which is the cubemap we loaded. The <code class="highlighter-rouge">glsl</code> type <code class="highlighter-rouge">samplerCube</code> is for holding cubemap textures. We also define a varying variable <code class="highlighter-rouge">vPosition</code> which is our position vector.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">uniform</span> <span class="kt">samplerCube</span> <span class="n">skybox</span><span class="p">;</span>
<span class="k">varying</span> <span class="kt">vec3</span> <span class="n">vPosition</span><span class="p">;</span>
</code></pre></div></div>

<p>We set <code class="highlighter-rouge">vPosition</code> as our position in world coordinates. We can use these world coordinates of our cube as our texture coordinates to color the faces of the box.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vPosition</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">modelMatrix</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">));</span>
</code></pre></div></div>

<p>The last thing we need to do is ensure that we always remain inside the skybox. We don’t want to be able to zoom past it or go outside our background. A simple way to do this is to move with the camera, so we always remain inside the skybox. To do this we can alter our output of <code class="highlighter-rouge">gl_Position</code></p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">gl_Position</span> <span class="o">=</span> <span class="n">projectionMatrix</span> <span class="o">*</span> <span class="n">viewMatrix</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">position</span> <span class="o">+</span> <span class="n">cameraPosition</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

<p>The full vertex shader is <a href="https://github.com/k1mby/teapot-demo/raw/master/shaders/skybox.vs.glsl">here</a></p>

<h3 id="fragment-shader">Fragment Shader</h3>

<p>Our fragment shader is quite simple as well. <code class="highlighter-rouge">glsl</code> provides the <code class="highlighter-rouge">textureCube()</code> function that samples a cubemap texture for us. <code class="highlighter-rouge">textureCube()</code> takes in a cubemap and a <code class="highlighter-rouge">vec3</code> coordinate. It returns a texel, or the color at the given coordinate. We will use our world coordinates as the texture coordinates in this case which means that we’re coloring our box geometry according to the six faces of our cubemap.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">textureCube</span><span class="p">(</span><span class="n">skybox</span><span class="p">,</span> <span class="n">vPosition</span><span class="p">);</span>
</code></pre></div></div>

<p>The full fragment shader is <a href="https://github.com/k1mby/teapot-demo/raw/master/shaders/skybox.fs.glsl">here</a>
<br />
<br />
<br />
<a href="#top">Back to top</a></p>

<hr />

<p><a name="reflection"></a></p>
<h3 id="reflection">Reflection</h3>

<p>The general idea behind the reflection shader is that we can calculate the bounce vector or reflection vector and then use this to sample our cubemap. The bounce vector points towards the area that you would see in a mirror, the result is a surface that looks like it is reflecting the skybox.</p>

<p>The bounce vector can be imagined as bouncing off our surface and pointing in the direction of some area of the cubemap. Where the bounce vector points then determines the color of the surface.</p>

<h4 id="vertex-shader-1">Vertex Shader</h4>

<p>To calculate our bounce or reflected vector, we need a view vector and our surface normal, we can use the negative of our position as our view vector. We also define the skybox as a uniform.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">uniform</span> <span class="kt">samplerCube</span> <span class="n">skybox</span><span class="p">;</span>
<span class="k">varying</span> <span class="kt">vec3</span> <span class="n">vNormal</span><span class="p">;</span>
<span class="k">varying</span> <span class="kt">vec3</span> <span class="n">vPosition</span><span class="p">;</span>
</code></pre></div></div>

<p>As usual we set our varying variables to pass to the fragment shader.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vNormal</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">modelMatrix</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">));</span>
<span class="n">vPosition</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">modelMatrix</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">));</span>
</code></pre></div></div>

<p>The full vertex shader is <a href="https://github.com/k1mby/teapot-demo/raw/master/shaders/reflection.vs.glsl">here</a></p>

<h4 id="fragment-shader-1">Fragment Shader</h4>

<p>In the fragment shader we need to calculate the bounce vector and then use this to sample our cubemap. OpenGL provides a <code class="highlighter-rouge">reflect()</code> function that returns the bounce vector given a normal and and incident vector (our view vector). Below is how to calculate the bounce vector by hand.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="kt">vec3</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">v</span> <span class="o">+</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
</code></pre></div></div>

<p>Lastly we simply sample the cubemap using the bounce vector.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">textureCube</span><span class="p">(</span><span class="n">skybox</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div></div>

<p>The full fragment shader is <a href="https://github.com/k1mby/teapot-demo/raw/master/shaders/reflection.fs.glsl">here</a>
<br />
<br />
<br />
<a href="#top">Back to top</a></p>

<hr />

<h3 id="refraction">Refraction</h3>

<p>We’ll use <a href="https://en.wikipedia.org/wiki/Snell%27s_law">Snell’s Law</a> for our <a href="https://en.wikipedia.org/wiki/Refraction">refraction</a> shader. Snell’s law describes how to calculate the change in vector direction as it goes through a material. For example, the way light bends as it travels though water or a glass.</p>

<h4 id="vertex-shader-2">Vertex Shader</h4>

<p>Our vertex shader is the same as reflection. We just need to pass the surface normal and our position to the fragment shader. In addition to defining the skybox as a uniform, we will also define a uniform to control the <a href="https://en.wikipedia.org/wiki/Refractive_index">refractive index</a>. Transparent materials have a refractive index between 1 and 2, you can see the effect of this by running the demo.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">uniform</span> <span class="kt">float</span> <span class="n">index</span><span class="p">;</span>
</code></pre></div></div>

<p>The full vertex shader is <a href="https://github.com/k1mby/teapot-demo/raw/master/shaders/refraction.vs.glsl">here</a></p>

<h4 id="fragment-shader-2">Fragment Shader</h4>

<p>As with reflection, OpenGL also provides a <code class="highlighter-rouge">refract()</code> function that, given the incidence vector (our view vector), surface normal, and refractive index, returns the refraction direction. Below we show how to calculate this by hand.</p>

<p>After normalizing our vectors we first calculate the angle of refraction, which describes how much the light bends.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">angle</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">pow</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">pow</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">));</span>
</code></pre></div></div>

<p>Then we calculate our refracted vector using Snell’s Law.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
     <span class="n">r</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
 <span class="k">else</span>
     <span class="n">r</span> <span class="o">=</span> <span class="n">index</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="n">dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
</code></pre></div></div>
<p>The full fragment shader is <a href="https://github.com/k1mby/teapot-demo/raw/master/shaders/refraction.fs.glsl">here</a>
<br />
<br />
<br />
<a href="#top">Back to top</a></p>


      </section>
      <footer>
        
        <p>This project is maintained by <a href="http://github.com/k1mby">k1mby</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>


  
  </body>
</html>
